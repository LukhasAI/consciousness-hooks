export interface HookConfig {
    name: string;
    description: string;
    emoji: string;
    filePatterns: string[];
    selectedPatterns: string[];
    customPatterns: string;
    fixActions: string[];
    replacements: string[];
    defaultAction: 'ask' | 'preview' | 'auto' | 'skip';
    severity: 'info' | 'warning' | 'error';
}

export interface HookTestResult {
    success: boolean;
    message: string;
    suggestions: number;
    errors: string[];
}

export class HookBuilder {
    private builtInPatterns: Map<string, PatternDefinition> = new Map();

    constructor() {
        this.initializeBuiltInPatterns();
    }

    public generatePreview(config: HookConfig): Promise<string> {
        return Promise.resolve(this.buildHookScript(config));
    }

    public async saveHook(config: HookConfig): Promise<void> {
        const script = this.buildHookScript(config);
        const fileName = `${config.name.toLowerCase().replace(/\s+/g, '-')}-hook.sh`;
        
        // This would save to the git-hooks directory
        console.log(`Would save hook to: ${fileName}`);
        console.log(script);
    }

    public async testHook(config: HookConfig): Promise<HookTestResult> {
        try {
            // Validate configuration
            const errors = this.validateConfig(config);
            if (errors.length > 0) {
                return {
                    success: false,
                    message: 'Configuration errors found',
                    suggestions: 0,
                    errors
                };
            }

            // Simulate running the hook on a test file
            const testResult = await this.simulateHookExecution(config);
            
            return {
                success: true,
                message: `Hook test completed successfully`,
                suggestions: testResult.suggestions,
                errors: []
            };

        } catch (error) {
            return {
                success: false,
                message: `Test failed: ${error}`,
                suggestions: 0,
                errors: [String(error)]
            };
        }
    }

    private buildHookScript(config: HookConfig): string {
        const script = `#!/bin/bash
# ${config.emoji} ${config.name}
# ${config.description}
# 
# Generated by Interactive Git Hooks VS Code Extension
# Created: ${new Date().toISOString()}

# Source the interactive framework
SCRIPT_DIR="$(cd "$(dirname "\${BASH_SOURCE[0]}")" && pwd)"
source "\$SCRIPT_DIR/interactive-hook-framework.sh"

# Hook configuration
HOOK_NAME="${config.name}"
HOOK_EMOJI="${config.emoji}"
HOOK_DESCRIPTION="${config.description}"
DEFAULT_ACTION="${config.defaultAction}"
SEVERITY="${config.severity}"

# File patterns this hook should process
FILE_PATTERNS=(${config.filePatterns.map(p => `"${p}"`).join(' ')})

# Analysis function
analyze_file() {
    local file_path="$1"
    local suggestions=()
    
    # Check if file matches our patterns
    local matches_pattern=false
    for pattern in "\${FILE_PATTERNS[@]}"; do
        if [[ "\$file_path" == \$pattern ]]; then
            matches_pattern=true
            break
        fi
    done
    
    if [[ "\$matches_pattern" != "true" ]]; then
        return 0
    fi
    
    log_info "Analyzing \$file_path with ${config.name}"
    
    # Built-in pattern checks
${this.generatePatternChecks(config)}
    
    # Custom pattern checks
${this.generateCustomPatternChecks(config)}
    
    # Text replacements
${this.generateReplacementChecks(config)}
    
    # Output suggestions count
    echo "\${#suggestions[@]}"
    return 0
}

# Enhancement function
apply_enhancement() {
    local file_path="$1"
    local backup_file="\${file_path}.backup-\$(date +%s)"
    
    # Create backup
    cp "\$file_path" "\$backup_file"
    log_info "Created backup: \$backup_file"
    
    # Apply fixes
${this.generateFixActions(config)}
    
    # Apply text replacements
${this.generateReplacements(config)}
    
    log_success "Applied enhancements to \$file_path"
    return 0
}

# Run the interactive hook framework
interactive_hook_main "\$@"
`;

        return script;
    }

    private generatePatternChecks(config: HookConfig): string {
        let checks = '';
        
        for (const pattern of config.selectedPatterns) {
            const definition = this.builtInPatterns.get(pattern);
            if (definition) {
                checks += `
    # Check for ${definition.name}
    if ${definition.checkFunction}; then
        suggestions+=("${definition.suggestion}")
        echo "SUGGESTION:${definition.type}:\$line_num:${definition.description}:\$original_line:\$enhanced_line"
    fi
`;
            }
        }
        
        return checks;
    }

    private generateCustomPatternChecks(config: HookConfig): string {
        if (!config.customPatterns.trim()) {
            return '';
        }
        
        return `
    # Custom pattern checks
    while IFS= read -r line_num; do
        line_content=\$(sed -n "\${line_num}p" "\$file_path")
        if echo "\$line_content" | grep -qE "${config.customPatterns}"; then
            suggestions+=("Custom pattern match at line \$line_num")
            echo "SUGGESTION:custom:\$line_num:Custom pattern found:\$line_content:# TODO: Review this line"
        fi
    done < <(grep -n -E "${config.customPatterns}" "\$file_path" | cut -d: -f1)
`;
    }

    private generateReplacementChecks(config: HookConfig): string {
        let checks = '';
        
        for (const replacement of config.replacements) {
            const [find, replace] = replacement.split('|');
            if (find && replace) {
                checks += `
    # Check for ${find} -> ${replace}
    while IFS= read -r line_num; do
        line_content=\$(sed -n "\${line_num}p" "\$file_path")
        if echo "\$line_content" | grep -qF "${find}"; then
            enhanced_line=\$(echo "\$line_content" | sed "s/${find}/${replace}/g")
            suggestions+=("Replace ${find} with ${replace} at line \$line_num")
            echo "SUGGESTION:replacement:\$line_num:Replace ${find} with ${replace}:\$line_content:\$enhanced_line"
        fi
    done < <(grep -n -F "${find}" "\$file_path" | cut -d: -f1)
`;
            }
        }
        
        return checks;
    }

    private generateFixActions(config: HookConfig): string {
        let actions = '';
        
        for (const action of config.fixActions) {
            actions += `
    # Fix: ${action}
    log_info "Applying fix: ${action}"
    # Implementation would depend on the specific action
`;
        }
        
        return actions;
    }

    private generateReplacements(config: HookConfig): string {
        let replacements = '';
        
        for (const replacement of config.replacements) {
            const [find, replace] = replacement.split('|');
            if (find && replace) {
                replacements += `
    # Replace ${find} with ${replace}
    sed -i "s/${find}/${replace}/g" "\$file_path"
`;
            }
        }
        
        return replacements;
    }

    private validateConfig(config: HookConfig): string[] {
        const errors: string[] = [];
        
        if (!config.name.trim()) {
            errors.push('Hook name is required');
        }
        
        if (!config.description.trim()) {
            errors.push('Hook description is required');
        }
        
        if (config.filePatterns.length === 0) {
            errors.push('At least one file pattern is required');
        }
        
        if (config.selectedPatterns.length === 0 && !config.customPatterns.trim() && config.replacements.length === 0) {
            errors.push('At least one pattern, custom check, or replacement is required');
        }
        
        // Validate replacement format
        for (const replacement of config.replacements) {
            if (!replacement.includes('|')) {
                errors.push(`Invalid replacement format: ${replacement}. Use "find|replace" format.`);
            }
        }
        
        return errors;
    }

    private async simulateHookExecution(config: HookConfig): Promise<{ suggestions: number }> {
        // Simulate finding suggestions based on configuration
        let suggestions = 0;
        
        suggestions += config.selectedPatterns.length * 2; // Assume 2 matches per pattern
        suggestions += config.replacements.length; // One match per replacement
        
        if (config.customPatterns.trim()) {
            suggestions += 1; // Assume custom pattern finds something
        }
        
        return { suggestions };
    }

    private initializeBuiltInPatterns(): void {
        this.builtInPatterns.set('missing-docstring', {
            name: 'Missing Docstrings',
            type: 'documentation',
            description: 'Add docstring to function',
            checkFunction: 'grep -q "def " "$file_path" && ! grep -q "\"\"\"" "$file_path"',
            suggestion: 'Add docstring to function',
            enhancement: '"""Add function description here."""'
        });
        
        this.builtInPatterns.set('hardcoded-values', {
            name: 'Hardcoded Values',
            type: 'quality',
            description: 'Replace hardcoded values with constants',
            checkFunction: 'grep -qE "\\b[0-9]{3,}\\b" "$file_path"',
            suggestion: 'Consider using constants instead of hardcoded values',
            enhancement: 'CONSTANT_VALUE = {value}'
        });
        
        this.builtInPatterns.set('long-lines', {
            name: 'Long Lines',
            type: 'formatting',
            description: 'Break long lines',
            checkFunction: 'awk "length > 120" "$file_path" | wc -l | grep -v "^0$"',
            suggestion: 'Break long line for better readability',
            enhancement: '# Line broken for readability'
        });
        
        this.builtInPatterns.set('missing-tests', {
            name: 'Missing Tests',
            type: 'quality',
            description: 'Add test coverage',
            checkFunction: 'grep -q "def test_" "$file_path" || grep -q "class Test" "$file_path"',
            suggestion: 'Consider adding test coverage',
            enhancement: '# TODO: Add test coverage'
        });
        
        this.builtInPatterns.set('security-issues', {
            name: 'Security Issues',
            type: 'security',
            description: 'Fix security vulnerability',
            checkFunction: 'grep -qE "(eval|exec|subprocess\\.call)" "$file_path"',
            suggestion: 'Review for security implications',
            enhancement: '# SECURITY: Review this code'
        });
        
        this.builtInPatterns.set('code-smells', {
            name: 'Code Smells',
            type: 'quality',
            description: 'Improve code quality',
            checkFunction: 'grep -qE "(TODO|FIXME|XXX|HACK)" "$file_path"',
            suggestion: 'Address code smell',
            enhancement: '# REVIEWED: Code smell addressed'
        });
        
        this.builtInPatterns.set('missing-headers', {
            name: 'Missing Headers',
            type: 'header',
            description: 'Add file header',
            checkFunction: '[ $(head -n 5 "$file_path" | grep -c "^#") -eq 0 ]',
            suggestion: 'Add file header with description',
            enhancement: '# File: {filename}\n# Description: {description}\n# Author: {author}'
        });
        
        this.builtInPatterns.set('inconsistent-formatting', {
            name: 'Inconsistent Formatting',
            type: 'formatting',
            description: 'Fix formatting inconsistencies',
            checkFunction: 'grep -qE "\\s+$" "$file_path"',
            suggestion: 'Remove trailing whitespace',
            enhancement: '# Trailing whitespace removed'
        });
    }
}

interface PatternDefinition {
    name: string;
    type: string;
    description: string;
    checkFunction: string;
    suggestion: string;
    enhancement: string;
}
